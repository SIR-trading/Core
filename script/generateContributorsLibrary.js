const fs = require("fs");
const path = require("path");

// Configuration
const FUNDRAISING_PERCENTAGE = 10; // 10% of total tokens for fundraising
const SALE_CAP_USD = 100000; // $100,000 sale cap
const BC_BOOST_PER_CENT = 6; // 6% boost per NFT
const TREASURY_ADDRESS = "0x1234567890123456789012345678901234567890"; // Add your treasury address here
const TREASURY_ALLOCATION = 10; // 10%

// File paths
const SPICE_PATH = path.join(__dirname, "../contributors/spice-contributors.json");
const FUNDRAISING_PATH = path.join(__dirname, "../contributors/usd-contributors.json");
const OUTPUT_PATH = path.join(__dirname, "../src/libraries/Contributors.sol");

// Load and process data
const spiceContributors = JSON.parse(fs.readFileSync(SPICE_PATH, "utf8"));
const fundraisingData = JSON.parse(fs.readFileSync(FUNDRAISING_PATH, "utf8"));

function logAllocations(allocations) {
    console.log("\nAllocation Breakdown:");
    allocations.forEach(({ address, allocation, ens }) => {
        const ensInfo = ens ? ` (ENS: ${ens})` : "";
        console.log(`- ${address}: ${allocation.toFixed(2)}%${ensInfo}`);
    });
}

// Calculate fundraising allocations
const processFundraising = () => {
    return fundraisingData.contributors.map((c) => {
        const baseRatio = c.contribution / SALE_CAP_USD;
        const baseAllocation = baseRatio * FUNDRAISING_PERCENTAGE;
        const boost = 1 + (c.lock_nfts * BC_BOOST_PER_CENT) / 100;
        return {
            address: c.address,
            allocation: baseAllocation * boost
        };
    });
};

// Process spice contributors (convert basis points to percentage)
const processSpice = () =>
    spiceContributors.map((c) => ({
        address: c.address,
        allocation: c.allocation / 100 // Convert basis points to percentage
    }));

// Combine allocations
const combineAllocations = () => {
    const allocations = new Map();

    // Helper to add allocations with ENS
    const addAllocation = (address, allocation, ens) => {
        const key = address.toLowerCase();
        const existing = allocations.get(key) || { allocation: 0, ens: "" };

        allocations.set(key, {
            address,
            allocation: existing.allocation + allocation,
            ens: ens || existing.ens // Preserve existing ENS if any
        });
    };

    // Process spice contributors (no ENS)
    processSpice().forEach(({ address, allocation }) => addAllocation(address, allocation, ""));

    // Process fundraising contributors (with ENS)
    fundraisingData.contributors.forEach((c) => {
        const baseRatio = c.contribution / SALE_CAP_USD;
        const baseAllocation = baseRatio * FUNDRAISING_PERCENTAGE;
        const boost = 1 + (c.lock_nfts * BC_BOOST_PER_CENT) / 100;
        addAllocation(c.address, baseAllocation * boost, c.ens);
    });

    // Add treasury allocation
    addAllocation(TREASURY_ADDRESS, TREASURY_ALLOCATION, "");

    return Array.from(allocations.values()).sort((a, b) => b.allocation - a.allocation);
};

function calculateLpAllocation(totalContributorAllocation) {
    // Convert percentages to fractions
    const totalContributorFraction = totalContributorAllocation / 100;
    const lpFraction = 1 - totalContributorFraction; // This is now < 1

    // Scale to 1e17 (17 decimal places) for Solidity fixed-point math
    const scaledLpFraction = Math.round(lpFraction * 1e17);

    return {
        percentage: lpFraction * 100, // For display purposes
        fraction: scaledLpFraction.toString().padStart(17, "0")
    };
}

// Generate Solidity library
const generateLibrary = (allocations) => {
    const typeMax = 0xffffffffffffff; // uint56.max
    const totalAllocation = allocations.reduce((sum, c) => sum + c.allocation, 0);

    // Calculate LP allocation
    const lpAllocation = calculateLpAllocation(totalAllocation);

    console.log(`\nLP Allocation Details:`);
    console.log(`- Total contributor allocation: ${totalAllocation.toFixed(7)}%`);
    console.log(`- LP allocation percentage: ${lpAllocation.percentage.toFixed(7)}%`);
    console.log(`- LP fraction (1e17 precision): ${lpAllocation.fraction}`);

    return `// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

library Contributors {
    /** @dev This library is generated by the script \\\`generate-contributors.js\\\`.
        @dev Sum of all allocations: ${totalAllocation.toFixed(2)}% of total supply
        @dev An allocation of type(uint56).max means 100% of the issuance reserved for non-LPers.
        @dev Sum of all allocations should be equal to type(uint56).max or less.
    */
    function getAllocation(address contributor) internal pure returns (uint56) {
${allocations
    .map(
        (c, i) =>
            `        ${i === 0 ? "" : "else "}if (contributor == address(${c.address})) return ${Math.round(
                (c.allocation / 100) * typeMax
            ).toString()};`
    )
    .join("\n")}
        
        return 0;
    }
}`;
};

// Main execution
try {
    const allocations = combineAllocations();
    logAllocations(allocations); // Add this line

    const libraryCode = generateLibrary(allocations);
    fs.writeFileSync(OUTPUT_PATH, libraryCode);
    console.log(`\nSuccessfully generated Contributors.sol with ${allocations.length} entries`);
} catch (error) {
    console.error("Error generating allocations:", error);
    process.exit(1);
}
