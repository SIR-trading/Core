// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import "forge-std/Test.sol";
import {Fees} from "src/libraries/Fees.sol";
import {FullMath} from "src/libraries/FullMath.sol";

contract FeesTest is Test {
    function testFuzz_FeeAPE(uint152 collateralAmount, uint16 baseFee, int8 leverageTier, uint8 tax) public {
        // Constraint leverageTier to supported values
        leverageTier = int8(_bound(leverageTier, -3, 2));

        (uint152 collateralInOrWidthdrawn, uint152 treasuryFee, uint152 lpersFee, uint152 polFee) = Fees.hiddenFeeAPE(
            collateralAmount,
            baseFee,
            leverageTier,
            tax
        );

        assertEq(
            collateralInOrWidthdrawn + treasuryFee + lpersFee + polFee,
            collateralAmount,
            "collateral deposited + comission is not equal to collateral in"
        );

        uint256 comissionLowerBound;
        uint256 comissionUpperBound;
        if (leverageTier >= 0) {
            comissionLowerBound = FullMath.mulDiv(
                collateralInOrWidthdrawn,
                uint256(baseFee) << uint8(leverageTier),
                10000
            );
            comissionUpperBound = FullMath.mulDivRoundingUp(
                collateralInOrWidthdrawn + 1,
                uint256(baseFee) << uint8(leverageTier),
                10000
            );
        } else {
            comissionLowerBound = FullMath.mulDiv(collateralInOrWidthdrawn, baseFee, 10000 << uint8(-leverageTier));
            comissionUpperBound = FullMath.mulDivRoundingUp(
                collateralInOrWidthdrawn + 1,
                baseFee,
                10000 << uint8(-leverageTier)
            );
        }

        assertLe(comissionLowerBound, comission, "Fee computation is not correct");
        assertGe(comissionUpperBound, comission, "Fee computation is not correct");
    }

    function testFuzz_FeeTEA(uint8 lpFee, uint152 collateralAmount) public {
        (uint152 collateralFeeFree, uint152 comission) = Fees.hiddenFee(lpFee, collateralAmount, 0);

        assertEq(
            collateralFeeFree + comission,
            collateralAmount,
            "collateral deposited + comission is not equal to collateral in"
        );

        uint256 comissionLowerBound;
        uint256 comissionUpperBound;
        comissionLowerBound = FullMath.mulDiv(collateralFeeFree, lpFee, 10000);
        comissionUpperBound = FullMath.mulDivRoundingUp(
            collateralFeeFree < type(uint152).max ? collateralFeeFree + 1 : collateralFeeFree,
            lpFee,
            10000
        );

        assertLe(comissionLowerBound, comission, "Fee computation is not correct");
        assertGe(comissionUpperBound, comission, "Fee computation is not correct");
    }
}
