// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import {Vault} from "src/Vault.sol";
import {APE} from "src/APE.sol";
import {IVaultExternal} from "src/Interfaces/IVaultExternal.sol";
import {Addresses} from "src/libraries/Addresses.sol";
import {VaultStructs} from "src/libraries/VaultStructs.sol";

contract APETest is Test {
    event Transfer(address indexed from, address indexed to, uint256 amount);

    APE ape;
    address alice;
    address bob;
    address charlie;

    /// @dev Auxiliary function for minting APE tokens
    function _mint(address account, uint256 amount) private {
        uint256 totalSupply = uint256(vm.load(address(ape), bytes32(uint256(2))));
        totalSupply += amount;
        vm.store(address(ape), bytes32(uint256(2)), bytes32(totalSupply));

        uint256 balance = uint256(vm.load(address(ape), keccak256(abi.encode(account, bytes32(uint256(3))))));
        balance += amount;
        vm.store(address(ape), keccak256(abi.encode(account, bytes32(uint256(3)))), bytes32(balance));
    }

    /// @dev Auxiliary function for burning APE tokens
    function _burn(address account, uint256 amount) private {
        uint256 totalSupply = uint256(vm.load(address(ape), bytes32(uint256(2))));
        totalSupply -= amount;
        vm.store(address(ape), bytes32(uint256(2)), bytes32(totalSupply));

        uint256 balance = uint256(vm.load(address(ape), keccak256(abi.encode(account, bytes32(uint256(3))))));
        balance -= amount;
        vm.store(address(ape), keccak256(abi.encode(account, bytes32(uint256(3)))), bytes32(balance));
    }

    function setUp() public {
        vm.mockCall(
            address(this),
            abi.encodeWithSelector(Vault.latestTokenParams.selector),
            abi.encode(
                "Tokenized ETH/USDC with x1.25 leverage",
                "APE-42",
                uint8(18),
                Addresses.ADDR_USDC,
                Addresses.ADDR_WETH,
                int8(-2)
            )
        );
        ape = new APE();

        alice = vm.addr(1);
        bob = vm.addr(2);
        charlie = vm.addr(3);
    }

    function test_initialConditions() public {
        assertEq(ape.totalSupply(), 0);
        assertEq(ape.balanceOf(alice), 0);
        assertEq(ape.balanceOf(bob), 0);
        assertEq(ape.debtToken(), Addresses.ADDR_USDC);
        assertEq(ape.collateralToken(), Addresses.ADDR_WETH);
        assertEq(ape.leverageTier(), -2);
        assertEq(ape.name(), "Tokenized ETH/USDC with x1.25 leverage");
        assertEq(ape.symbol(), "APE-42");
        assertEq(ape.decimals(), 18);
    }

    function testFuzz_transfer(uint256 transferAmount, uint256 mintAmount) public {
        transferAmount = _bound(transferAmount, 1, type(uint256).max);
        mintAmount = _bound(mintAmount, transferAmount, type(uint256).max);

        _mint(alice, mintAmount);

        vm.expectEmit();
        emit Transfer(alice, bob, transferAmount);
        vm.prank(alice);
        assertTrue(ape.transfer(bob, transferAmount));
        assertEq(ape.balanceOf(bob), transferAmount);
        assertEq(ape.balanceOf(alice), mintAmount - transferAmount);
    }

    function testFuzz_transferMoreThanBalance(uint256 transferAmount, uint256 mintAmount) public {
        transferAmount = _bound(transferAmount, 1, type(uint256).max);
        mintAmount = _bound(mintAmount, 0, transferAmount - 1);

        _mint(alice, mintAmount);

        vm.expectRevert();
        ape.transfer(bob, transferAmount);
    }

    function testFuzz_approve(uint256 amount) public {
        vm.prank(alice);
        assertTrue(ape.approve(bob, amount));
        assertEq(ape.allowance(alice, bob), amount);
    }

    function testFuzz_transferFrom(uint256 transferAmount, uint256 mintAmount) public {
        transferAmount = _bound(transferAmount, 1, type(uint256).max);
        mintAmount = _bound(mintAmount, transferAmount, type(uint256).max);

        _mint(bob, mintAmount);

        vm.prank(bob);
        assertTrue(ape.approve(alice, mintAmount));
        assertEq(ape.allowance(bob, alice), mintAmount);

        vm.expectEmit();
        emit Transfer(bob, charlie, transferAmount);
        vm.prank(alice);
        assertTrue(ape.transferFrom(bob, charlie, transferAmount));

        assertEq(ape.balanceOf(bob), mintAmount - transferAmount);
        assertEq(ape.allowance(bob, alice), mintAmount == type(uint256).max ? mintAmount : mintAmount - transferAmount);
        assertEq(ape.balanceOf(alice), 0);
        assertEq(ape.balanceOf(charlie), transferAmount);
    }

    function testFuzz_transferFromWithoutApproval(uint256 transferAmount, uint256 mintAmount) public {
        transferAmount = _bound(transferAmount, 1, type(uint256).max);
        mintAmount = _bound(mintAmount, transferAmount, type(uint256).max);

        _mint(bob, mintAmount);

        vm.expectRevert();
        vm.prank(alice);
        ape.transferFrom(bob, alice, transferAmount);
    }

    function testFuzz_transferFromExceedAllowance(
        uint256 transferAmount,
        uint256 mintAmount,
        uint256 allowedAmount
    ) public {
        transferAmount = _bound(transferAmount, 1, type(uint256).max);
        mintAmount = _bound(mintAmount, transferAmount, type(uint256).max);
        allowedAmount = _bound(allowedAmount, 0, transferAmount - 1);

        _mint(bob, mintAmount);

        vm.prank(bob);
        ape.approve(alice, allowedAmount);

        vm.expectRevert();
        vm.prank(alice);
        ape.transferFrom(bob, alice, transferAmount);
    }

    function testFuzz_mint(
        uint16 baseFee,
        uint8 tax,
        uint152 collateralDepositedA,
        uint152 collateralDepositedB
    ) public {
        VaultStructs.Reserves memory reserves;

        vm.expectEmit();
        emit Transfer(address(0), alice, collateralDepositedA);
        // address to,
        // uint16 baseFee,
        // uint8 tax,
        // VaultStructs.Reserves memory reserves,
        // uint152 collateralDeposited
        ape.mint(alice, baseFee, tax, mintAmountA);
        assertEq(ape.balanceOf(alice), mintAmountA);
        assertEq(ape.totalSupply(), mintAmountA);

        mintAmountB = _bound(mintAmountB, 0, type(uint152).max - mintAmountA);

        vm.expectEmit();
        emit Transfer(address(0), bob, mintAmountB);
        ape.mint(bob, mintAmountB);
        assertEq(ape.balanceOf(bob), mintAmountB);
        assertEq(ape.totalSupply(), mintAmountA + mintAmountB);
    }

    // function testFuzz_mintFails(uint152 mintAmountA, uint152 mintAmountB) public {
    //     mintAmountA = _bound(mintAmountA, 1, type(uint152).max);
    //     _mint(alice, mintAmountA);

    //     mintAmountB = _bound(mintAmountB, type(uint152).max - mintAmountA + 1, type(uint152).max);
    //     vm.expectRevert();
    //     _mint(bob, mintAmountB);
    // }

    // function testFail_mintByNonOwner() public {
    //     vm.prank(alice);
    //     APE(ape).mint(bob, 1000); // This should fail because bob is not the owner
    // }

    // function testFuzz_burn(uint152 mintAmountA, uint152 mintAmountB, uint256 burnAmountB) public {
    //     mintAmountB = _bound(mintAmountB, 0, type(uint152).max - mintAmountA);
    //     burnAmountB = _bound(burnAmountB, 0, mintAmountB);

    //     _mint(alice, mintAmountA);
    //     _mint(bob, mintAmountB);

    //     vm.expectEmit();
    //     emit Transfer(bob, address(0), burnAmountB);
    //     _burn(bob, burnAmountB);

    //     assertEq(ape.balanceOf(bob), mintAmountB - burnAmountB);
    //     assertEq(ape.totalSupply(), mintAmountA + mintAmountB - burnAmountB);
    // }

    // function testFuzz_burnMoreThanBalance(uint152 mintAmountA, uint152 mintAmountB, uint256 burnAmountB) public {
    //     mintAmountA = _bound(mintAmountA, 0, type(uint152).max - 1);
    //     mintAmountB = _bound(mintAmountB, 1, type(uint152).max - mintAmountA);
    //     burnAmountB = _bound(burnAmountB, mintAmountB + 1, type(uint256).max);

    //     _mint(alice, mintAmountA);
    //     _mint(bob, mintAmountB);

    //     vm.expectRevert();
    //     _burn(bob, burnAmountB);
    // }
}
